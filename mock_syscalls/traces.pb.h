// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: traces.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_traces_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_traces_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>   // IWYU pragma: export
#include <google/protobuf/map.h>             // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_traces_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_traces_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_traces_2eproto;
namespace generated {
namespace traces {
class Fds;
struct FdsDefaultTypeInternal;
extern FdsDefaultTypeInternal _Fds_default_instance_;
class IoData;
struct IoDataDefaultTypeInternal;
extern IoDataDefaultTypeInternal _IoData_default_instance_;
class Parts;
struct PartsDefaultTypeInternal;
extern PartsDefaultTypeInternal _Parts_default_instance_;
class Parts_ReadDataEntry_DoNotUse;
struct Parts_ReadDataEntry_DoNotUseDefaultTypeInternal;
extern Parts_ReadDataEntry_DoNotUseDefaultTypeInternal
    _Parts_ReadDataEntry_DoNotUse_default_instance_;
class Root;
struct RootDefaultTypeInternal;
extern RootDefaultTypeInternal _Root_default_instance_;
class Syscall;
struct SyscallDefaultTypeInternal;
extern SyscallDefaultTypeInternal _Syscall_default_instance_;
class Syscalls;
struct SyscallsDefaultTypeInternal;
extern SyscallsDefaultTypeInternal _Syscalls_default_instance_;
class Terminated;
struct TerminatedDefaultTypeInternal;
extern TerminatedDefaultTypeInternal _Terminated_default_instance_;
}  // namespace traces
}  // namespace generated
PROTOBUF_NAMESPACE_OPEN
template <>
::generated::traces::Fds* Arena::CreateMaybeMessage<::generated::traces::Fds>(
    Arena*);
template <>
::generated::traces::IoData*
Arena::CreateMaybeMessage<::generated::traces::IoData>(Arena*);
template <>
::generated::traces::Parts*
Arena::CreateMaybeMessage<::generated::traces::Parts>(Arena*);
template <>
::generated::traces::Parts_ReadDataEntry_DoNotUse*
Arena::CreateMaybeMessage<::generated::traces::Parts_ReadDataEntry_DoNotUse>(
    Arena*);
template <>
::generated::traces::Root* Arena::CreateMaybeMessage<::generated::traces::Root>(
    Arena*);
template <>
::generated::traces::Syscall*
Arena::CreateMaybeMessage<::generated::traces::Syscall>(Arena*);
template <>
::generated::traces::Syscalls*
Arena::CreateMaybeMessage<::generated::traces::Syscalls>(Arena*);
template <>
::generated::traces::Terminated*
Arena::CreateMaybeMessage<::generated::traces::Terminated>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace generated {
namespace traces {

// ===================================================================

class Terminated final
    : public ::PROTOBUF_NAMESPACE_ID::internal::
          ZeroFieldsBase /* @@protoc_insertion_point(class_definition:generated.traces.Terminated)
                          */
{
 public:
  inline Terminated() : Terminated(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Terminated(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Terminated(const Terminated& from);
  Terminated(Terminated&& from) noexcept : Terminated() {
    *this = ::std::move(from);
  }

  inline Terminated& operator=(const Terminated& from) {
    CopyFrom(from);
    return *this;
  }
  inline Terminated& operator=(Terminated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Terminated& default_instance() {
    return *internal_default_instance();
  }
  static inline const Terminated* internal_default_instance() {
    return reinterpret_cast<const Terminated*>(&_Terminated_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;

  friend void swap(Terminated& a, Terminated& b) { a.Swap(&b); }
  inline void Swap(Terminated* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Terminated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Terminated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Terminated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Terminated& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Terminated& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

 public:
 private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.traces.Terminated";
  }

 protected:
  explicit Terminated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                      bool is_message_owned = false);

 public:
  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:generated.traces.Terminated)
 private:
  class _Internal;

  template <typename T>
  friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {};
  friend struct ::TableStruct_traces_2eproto;
};
// -------------------------------------------------------------------

class IoData final
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:generated.traces.IoData)
                   */
{
 public:
  inline IoData() : IoData(nullptr) {}
  ~IoData() override;
  explicit PROTOBUF_CONSTEXPR IoData(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IoData(const IoData& from);
  IoData(IoData&& from) noexcept : IoData() { *this = ::std::move(from); }

  inline IoData& operator=(const IoData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IoData& operator=(IoData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IoData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IoData* internal_default_instance() {
    return reinterpret_cast<const IoData*>(&_IoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;

  friend void swap(IoData& a, IoData& b) { a.Swap(&b); }
  inline void Swap(IoData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IoData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IoData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IoData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IoData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IoData& from) { IoData::MergeImpl(*this, from); }

 private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
                        const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

 public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target,
      ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

 private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IoData* other);

 private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.traces.IoData";
  }

 protected:
  explicit IoData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                  bool is_message_owned = false);

 public:
  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableDataFieldNumber = 1,
    kAdditionalLengthFieldNumber = 2,
  };
  // bytes available_data = 1;
  void clear_available_data();
  const std::string& available_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_available_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_available_data();
  PROTOBUF_NODISCARD std::string* release_available_data();
  void set_allocated_available_data(std::string* available_data);

 private:
  const std::string& _internal_available_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_available_data(
      const std::string& value);
  std::string* _internal_mutable_available_data();

 public:
  // uint64 additional_length = 2;
  void clear_additional_length();
  uint64_t additional_length() const;
  void set_additional_length(uint64_t value);

 private:
  uint64_t _internal_additional_length() const;
  void _internal_set_additional_length(uint64_t value);

 public:
  // @@protoc_insertion_point(class_scope:generated.traces.IoData)
 private:
  class _Internal;

  template <typename T>
  friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr available_data_;
    uint64_t additional_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union {
    Impl_ _impl_;
  };
  friend struct ::TableStruct_traces_2eproto;
};
// -------------------------------------------------------------------

class Fds final
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:generated.traces.Fds)
                   */
{
 public:
  inline Fds() : Fds(nullptr) {}
  ~Fds() override;
  explicit PROTOBUF_CONSTEXPR Fds(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fds(const Fds& from);
  Fds(Fds&& from) noexcept : Fds() { *this = ::std::move(from); }

  inline Fds& operator=(const Fds& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fds& operator=(Fds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fds& default_instance() { return *internal_default_instance(); }
  static inline const Fds* internal_default_instance() {
    return reinterpret_cast<const Fds*>(&_Fds_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;

  friend void swap(Fds& a, Fds& b) { a.Swap(&b); }
  inline void Swap(Fds* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Fds& from) { Fds::MergeImpl(*this, from); }

 private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
                        const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

 public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target,
      ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

 private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fds* other);

 private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.traces.Fds";
  }

 protected:
  explicit Fds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
               bool is_message_owned = false);

 public:
  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFdsFieldNumber = 1,
  };
  // repeated uint64 fds = 1;
  int fds_size() const;

 private:
  int _internal_fds_size() const;

 public:
  void clear_fds();

 private:
  uint64_t _internal_fds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& _internal_fds() const;
  void _internal_add_fds(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* _internal_mutable_fds();

 public:
  uint64_t fds(int index) const;
  void set_fds(int index, uint64_t value);
  void add_fds(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& fds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* mutable_fds();

  // @@protoc_insertion_point(class_scope:generated.traces.Fds)
 private:
  class _Internal;

  template <typename T>
  friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t> fds_;
    mutable std::atomic<int> _fds_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union {
    Impl_ _impl_;
  };
  friend struct ::TableStruct_traces_2eproto;
};
// -------------------------------------------------------------------

class Syscall final
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:generated.traces.Syscall)
                   */
{
 public:
  inline Syscall() : Syscall(nullptr) {}
  ~Syscall() override;
  explicit PROTOBUF_CONSTEXPR Syscall(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Syscall(const Syscall& from);
  Syscall(Syscall&& from) noexcept : Syscall() { *this = ::std::move(from); }

  inline Syscall& operator=(const Syscall& from) {
    CopyFrom(from);
    return *this;
  }
  inline Syscall& operator=(Syscall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Syscall& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kReturnWithCode = 1,
    kSuccessOutputData = 2,
    kIoData = 3,
    kTerminated = 4,
    kFds = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const Syscall* internal_default_instance() {
    return reinterpret_cast<const Syscall*>(&_Syscall_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;

  friend void swap(Syscall& a, Syscall& b) { a.Swap(&b); }
  inline void Swap(Syscall* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Syscall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Syscall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Syscall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Syscall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Syscall& from) { Syscall::MergeImpl(*this, from); }

 private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
                        const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

 public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target,
      ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

 private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Syscall* other);

 private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.traces.Syscall";
  }

 protected:
  explicit Syscall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                   bool is_message_owned = false);

 public:
  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReturnWithCodeFieldNumber = 1,
    kSuccessOutputDataFieldNumber = 2,
    kIoDataFieldNumber = 3,
    kTerminatedFieldNumber = 4,
    kFdsFieldNumber = 5,
  };
  // int64 return_with_code = 1;
  bool has_return_with_code() const;

 private:
  bool _internal_has_return_with_code() const;

 public:
  void clear_return_with_code();
  int64_t return_with_code() const;
  void set_return_with_code(int64_t value);

 private:
  int64_t _internal_return_with_code() const;
  void _internal_set_return_with_code(int64_t value);

 public:
  // uint64 success_output_data = 2;
  bool has_success_output_data() const;

 private:
  bool _internal_has_success_output_data() const;

 public:
  void clear_success_output_data();
  uint64_t success_output_data() const;
  void set_success_output_data(uint64_t value);

 private:
  uint64_t _internal_success_output_data() const;
  void _internal_set_success_output_data(uint64_t value);

 public:
  // .generated.traces.IoData io_data = 3;
  bool has_io_data() const;

 private:
  bool _internal_has_io_data() const;

 public:
  void clear_io_data();
  const ::generated::traces::IoData& io_data() const;
  PROTOBUF_NODISCARD ::generated::traces::IoData* release_io_data();
  ::generated::traces::IoData* mutable_io_data();
  void set_allocated_io_data(::generated::traces::IoData* io_data);

 private:
  const ::generated::traces::IoData& _internal_io_data() const;
  ::generated::traces::IoData* _internal_mutable_io_data();

 public:
  void unsafe_arena_set_allocated_io_data(::generated::traces::IoData* io_data);
  ::generated::traces::IoData* unsafe_arena_release_io_data();

  // .generated.traces.Terminated terminated = 4;
  bool has_terminated() const;

 private:
  bool _internal_has_terminated() const;

 public:
  void clear_terminated();
  const ::generated::traces::Terminated& terminated() const;
  PROTOBUF_NODISCARD ::generated::traces::Terminated* release_terminated();
  ::generated::traces::Terminated* mutable_terminated();
  void set_allocated_terminated(::generated::traces::Terminated* terminated);

 private:
  const ::generated::traces::Terminated& _internal_terminated() const;
  ::generated::traces::Terminated* _internal_mutable_terminated();

 public:
  void unsafe_arena_set_allocated_terminated(
      ::generated::traces::Terminated* terminated);
  ::generated::traces::Terminated* unsafe_arena_release_terminated();

  // .generated.traces.Fds fds = 5;
  bool has_fds() const;

 private:
  bool _internal_has_fds() const;

 public:
  void clear_fds();
  const ::generated::traces::Fds& fds() const;
  PROTOBUF_NODISCARD ::generated::traces::Fds* release_fds();
  ::generated::traces::Fds* mutable_fds();
  void set_allocated_fds(::generated::traces::Fds* fds);

 private:
  const ::generated::traces::Fds& _internal_fds() const;
  ::generated::traces::Fds* _internal_mutable_fds();

 public:
  void unsafe_arena_set_allocated_fds(::generated::traces::Fds* fds);
  ::generated::traces::Fds* unsafe_arena_release_fds();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:generated.traces.Syscall)
 private:
  class _Internal;
  void set_has_return_with_code();
  void set_has_success_output_data();
  void set_has_io_data();
  void set_has_terminated();
  void set_has_fds();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T>
  friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t return_with_code_;
      uint64_t success_output_data_;
      ::generated::traces::IoData* io_data_;
      ::generated::traces::Terminated* terminated_;
      ::generated::traces::Fds* fds_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];
  };
  union {
    Impl_ _impl_;
  };
  friend struct ::TableStruct_traces_2eproto;
};
// -------------------------------------------------------------------

class Syscalls final
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:generated.traces.Syscalls)
                   */
{
 public:
  inline Syscalls() : Syscalls(nullptr) {}
  ~Syscalls() override;
  explicit PROTOBUF_CONSTEXPR Syscalls(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Syscalls(const Syscalls& from);
  Syscalls(Syscalls&& from) noexcept : Syscalls() { *this = ::std::move(from); }

  inline Syscalls& operator=(const Syscalls& from) {
    CopyFrom(from);
    return *this;
  }
  inline Syscalls& operator=(Syscalls&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Syscalls& default_instance() {
    return *internal_default_instance();
  }
  static inline const Syscalls* internal_default_instance() {
    return reinterpret_cast<const Syscalls*>(&_Syscalls_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;

  friend void swap(Syscalls& a, Syscalls& b) { a.Swap(&b); }
  inline void Swap(Syscalls* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Syscalls* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Syscalls* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Syscalls>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Syscalls& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Syscalls& from) { Syscalls::MergeImpl(*this, from); }

 private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
                        const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

 public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target,
      ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

 private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Syscalls* other);

 private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.traces.Syscalls";
  }

 protected:
  explicit Syscalls(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                    bool is_message_owned = false);

 public:
  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSyscallsFieldNumber = 1,
    kArgsFieldNumber = 2,
  };
  // repeated .generated.traces.Syscall syscalls = 1;
  int syscalls_size() const;

 private:
  int _internal_syscalls_size() const;

 public:
  void clear_syscalls();
  ::generated::traces::Syscall* mutable_syscalls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::generated::traces::Syscall>*
  mutable_syscalls();

 private:
  const ::generated::traces::Syscall& _internal_syscalls(int index) const;
  ::generated::traces::Syscall* _internal_add_syscalls();

 public:
  const ::generated::traces::Syscall& syscalls(int index) const;
  ::generated::traces::Syscall* add_syscalls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::generated::traces::Syscall>&
  syscalls() const;

  // repeated bytes args = 2;
  int args_size() const;

 private:
  int _internal_args_size() const;

 public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const void* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();

 private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();

 public:
  // @@protoc_insertion_point(class_scope:generated.traces.Syscalls)
 private:
  class _Internal;

  template <typename T>
  friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::generated::traces::Syscall>
        syscalls_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union {
    Impl_ _impl_;
  };
  friend struct ::TableStruct_traces_2eproto;
};
// -------------------------------------------------------------------

class Parts_ReadDataEntry_DoNotUse
    : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<
          Parts_ReadDataEntry_DoNotUse, uint64_t, std::string,
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
 public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<
      Parts_ReadDataEntry_DoNotUse, uint64_t, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES>
      SuperType;
  Parts_ReadDataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Parts_ReadDataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Parts_ReadDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Parts_ReadDataEntry_DoNotUse& other);
  static const Parts_ReadDataEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Parts_ReadDataEntry_DoNotUse*>(
        &_Parts_ReadDataEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_traces_2eproto;
};

// -------------------------------------------------------------------

class Parts final
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:generated.traces.Parts)
                   */
{
 public:
  inline Parts() : Parts(nullptr) {}
  ~Parts() override;
  explicit PROTOBUF_CONSTEXPR Parts(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Parts(const Parts& from);
  Parts(Parts&& from) noexcept : Parts() { *this = ::std::move(from); }

  inline Parts& operator=(const Parts& from) {
    CopyFrom(from);
    return *this;
  }
  inline Parts& operator=(Parts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Parts& default_instance() {
    return *internal_default_instance();
  }
  static inline const Parts* internal_default_instance() {
    return reinterpret_cast<const Parts*>(&_Parts_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;

  friend void swap(Parts& a, Parts& b) { a.Swap(&b); }
  inline void Swap(Parts* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Parts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Parts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Parts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Parts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Parts& from) { Parts::MergeImpl(*this, from); }

 private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
                        const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

 public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target,
      ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

 private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parts* other);

 private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.traces.Parts";
  }

 protected:
  explicit Parts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                 bool is_message_owned = false);

 private:
  static void ArenaDtor(void* object);

 public:
  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputCellsFieldNumber = 2,
    kInputCellDataFieldNumber = 3,
    kWitnessesFieldNumber = 4,
    kInheritedFdsFieldNumber = 5,
    kReadDataFieldNumber = 6,
    kTxHashFieldNumber = 1,
    kOtherSyscallsFieldNumber = 7,
  };
  // repeated bytes input_cells = 2;
  int input_cells_size() const;

 private:
  int _internal_input_cells_size() const;

 public:
  void clear_input_cells();
  const std::string& input_cells(int index) const;
  std::string* mutable_input_cells(int index);
  void set_input_cells(int index, const std::string& value);
  void set_input_cells(int index, std::string&& value);
  void set_input_cells(int index, const char* value);
  void set_input_cells(int index, const void* value, size_t size);
  std::string* add_input_cells();
  void add_input_cells(const std::string& value);
  void add_input_cells(std::string&& value);
  void add_input_cells(const char* value);
  void add_input_cells(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& input_cells()
      const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_input_cells();

 private:
  const std::string& _internal_input_cells(int index) const;
  std::string* _internal_add_input_cells();

 public:
  // repeated bytes input_cell_data = 3;
  int input_cell_data_size() const;

 private:
  int _internal_input_cell_data_size() const;

 public:
  void clear_input_cell_data();
  const std::string& input_cell_data(int index) const;
  std::string* mutable_input_cell_data(int index);
  void set_input_cell_data(int index, const std::string& value);
  void set_input_cell_data(int index, std::string&& value);
  void set_input_cell_data(int index, const char* value);
  void set_input_cell_data(int index, const void* value, size_t size);
  std::string* add_input_cell_data();
  void add_input_cell_data(const std::string& value);
  void add_input_cell_data(std::string&& value);
  void add_input_cell_data(const char* value);
  void add_input_cell_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
  input_cell_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
  mutable_input_cell_data();

 private:
  const std::string& _internal_input_cell_data(int index) const;
  std::string* _internal_add_input_cell_data();

 public:
  // repeated bytes witnesses = 4;
  int witnesses_size() const;

 private:
  int _internal_witnesses_size() const;

 public:
  void clear_witnesses();
  const std::string& witnesses(int index) const;
  std::string* mutable_witnesses(int index);
  void set_witnesses(int index, const std::string& value);
  void set_witnesses(int index, std::string&& value);
  void set_witnesses(int index, const char* value);
  void set_witnesses(int index, const void* value, size_t size);
  std::string* add_witnesses();
  void add_witnesses(const std::string& value);
  void add_witnesses(std::string&& value);
  void add_witnesses(const char* value);
  void add_witnesses(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& witnesses()
      const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_witnesses();

 private:
  const std::string& _internal_witnesses(int index) const;
  std::string* _internal_add_witnesses();

 public:
  // repeated uint64 inherited_fds = 5;
  int inherited_fds_size() const;

 private:
  int _internal_inherited_fds_size() const;

 public:
  void clear_inherited_fds();

 private:
  uint64_t _internal_inherited_fds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>&
  _internal_inherited_fds() const;
  void _internal_add_inherited_fds(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>*
  _internal_mutable_inherited_fds();

 public:
  uint64_t inherited_fds(int index) const;
  void set_inherited_fds(int index, uint64_t value);
  void add_inherited_fds(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& inherited_fds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* mutable_inherited_fds();

  // map<uint64, bytes> read_data = 6;
  int read_data_size() const;

 private:
  int _internal_read_data_size() const;

 public:
  void clear_read_data();

 private:
  const ::PROTOBUF_NAMESPACE_ID::Map<uint64_t, std::string>&
  _internal_read_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map<uint64_t, std::string>*
  _internal_mutable_read_data();

 public:
  const ::PROTOBUF_NAMESPACE_ID::Map<uint64_t, std::string>& read_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map<uint64_t, std::string>* mutable_read_data();

  // bytes tx_hash = 1;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);

 private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(
      const std::string& value);
  std::string* _internal_mutable_tx_hash();

 public:
  // .generated.traces.Syscalls other_syscalls = 7;
  bool has_other_syscalls() const;

 private:
  bool _internal_has_other_syscalls() const;

 public:
  void clear_other_syscalls();
  const ::generated::traces::Syscalls& other_syscalls() const;
  PROTOBUF_NODISCARD ::generated::traces::Syscalls* release_other_syscalls();
  ::generated::traces::Syscalls* mutable_other_syscalls();
  void set_allocated_other_syscalls(
      ::generated::traces::Syscalls* other_syscalls);

 private:
  const ::generated::traces::Syscalls& _internal_other_syscalls() const;
  ::generated::traces::Syscalls* _internal_mutable_other_syscalls();

 public:
  void unsafe_arena_set_allocated_other_syscalls(
      ::generated::traces::Syscalls* other_syscalls);
  ::generated::traces::Syscalls* unsafe_arena_release_other_syscalls();

  // @@protoc_insertion_point(class_scope:generated.traces.Parts)
 private:
  class _Internal;

  template <typename T>
  friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> input_cells_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> input_cell_data_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> witnesses_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t> inherited_fds_;
    mutable std::atomic<int> _inherited_fds_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Parts_ReadDataEntry_DoNotUse, uint64_t, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES>
        read_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::generated::traces::Syscalls* other_syscalls_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union {
    Impl_ _impl_;
  };
  friend struct ::TableStruct_traces_2eproto;
};
// -------------------------------------------------------------------

class Root final
    : public ::PROTOBUF_NAMESPACE_ID::
          Message /* @@protoc_insertion_point(class_definition:generated.traces.Root)
                   */
{
 public:
  inline Root() : Root(nullptr) {}
  ~Root() override;
  explicit PROTOBUF_CONSTEXPR Root(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Root(const Root& from);
  Root(Root&& from) noexcept : Root() { *this = ::std::move(from); }

  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }
  inline Root& operator=(Root&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Root& default_instance() { return *internal_default_instance(); }
  enum ValueCase {
    kParts = 1,
    kSyscalls = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const Root* internal_default_instance() {
    return reinterpret_cast<const Root*>(&_Root_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;

  friend void swap(Root& a, Root& b) { a.Swap(&b); }
  inline void Swap(Root* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Root* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Root* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Root>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Root& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Root& from) { Root::MergeImpl(*this, from); }

 private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
                        const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

 public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(
      const char* ptr,
      ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target,
      ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

 private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Root* other);

 private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "generated.traces.Root";
  }

 protected:
  explicit Root(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                bool is_message_owned = false);

 public:
  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 1,
    kSyscallsFieldNumber = 3,
  };
  // .generated.traces.Parts parts = 1;
  bool has_parts() const;

 private:
  bool _internal_has_parts() const;

 public:
  void clear_parts();
  const ::generated::traces::Parts& parts() const;
  PROTOBUF_NODISCARD ::generated::traces::Parts* release_parts();
  ::generated::traces::Parts* mutable_parts();
  void set_allocated_parts(::generated::traces::Parts* parts);

 private:
  const ::generated::traces::Parts& _internal_parts() const;
  ::generated::traces::Parts* _internal_mutable_parts();

 public:
  void unsafe_arena_set_allocated_parts(::generated::traces::Parts* parts);
  ::generated::traces::Parts* unsafe_arena_release_parts();

  // .generated.traces.Syscalls syscalls = 3;
  bool has_syscalls() const;

 private:
  bool _internal_has_syscalls() const;

 public:
  void clear_syscalls();
  const ::generated::traces::Syscalls& syscalls() const;
  PROTOBUF_NODISCARD ::generated::traces::Syscalls* release_syscalls();
  ::generated::traces::Syscalls* mutable_syscalls();
  void set_allocated_syscalls(::generated::traces::Syscalls* syscalls);

 private:
  const ::generated::traces::Syscalls& _internal_syscalls() const;
  ::generated::traces::Syscalls* _internal_mutable_syscalls();

 public:
  void unsafe_arena_set_allocated_syscalls(
      ::generated::traces::Syscalls* syscalls);
  ::generated::traces::Syscalls* unsafe_arena_release_syscalls();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:generated.traces.Root)
 private:
  class _Internal;
  void set_has_parts();
  void set_has_syscalls();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T>
  friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::generated::traces::Parts* parts_;
      ::generated::traces::Syscalls* syscalls_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];
  };
  union {
    Impl_ _impl_;
  };
  friend struct ::TableStruct_traces_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Terminated

// -------------------------------------------------------------------

// IoData

// bytes available_data = 1;
inline void IoData::clear_available_data() {
  _impl_.available_data_.ClearToEmpty();
}
inline const std::string& IoData::available_data() const {
  // @@protoc_insertion_point(field_get:generated.traces.IoData.available_data)
  return _internal_available_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void IoData::set_available_data(ArgT0&& arg0,
                                                              ArgT... args) {
  _impl_.available_data_.SetBytes(static_cast<ArgT0&&>(arg0), args...,
                                  GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:generated.traces.IoData.available_data)
}
inline std::string* IoData::mutable_available_data() {
  std::string* _s = _internal_mutable_available_data();
  // @@protoc_insertion_point(field_mutable:generated.traces.IoData.available_data)
  return _s;
}
inline const std::string& IoData::_internal_available_data() const {
  return _impl_.available_data_.Get();
}
inline void IoData::_internal_set_available_data(const std::string& value) {
  _impl_.available_data_.Set(value, GetArenaForAllocation());
}
inline std::string* IoData::_internal_mutable_available_data() {
  return _impl_.available_data_.Mutable(GetArenaForAllocation());
}
inline std::string* IoData::release_available_data() {
  // @@protoc_insertion_point(field_release:generated.traces.IoData.available_data)
  return _impl_.available_data_.Release();
}
inline void IoData::set_allocated_available_data(std::string* available_data) {
  if (available_data != nullptr) {
  } else {
  }
  _impl_.available_data_.SetAllocated(available_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.available_data_.IsDefault()) {
    _impl_.available_data_.Set("", GetArenaForAllocation());
  }
#endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:generated.traces.IoData.available_data)
}

// uint64 additional_length = 2;
inline void IoData::clear_additional_length() {
  _impl_.additional_length_ = uint64_t{0u};
}
inline uint64_t IoData::_internal_additional_length() const {
  return _impl_.additional_length_;
}
inline uint64_t IoData::additional_length() const {
  // @@protoc_insertion_point(field_get:generated.traces.IoData.additional_length)
  return _internal_additional_length();
}
inline void IoData::_internal_set_additional_length(uint64_t value) {
  _impl_.additional_length_ = value;
}
inline void IoData::set_additional_length(uint64_t value) {
  _internal_set_additional_length(value);
  // @@protoc_insertion_point(field_set:generated.traces.IoData.additional_length)
}

// -------------------------------------------------------------------

// Fds

// repeated uint64 fds = 1;
inline int Fds::_internal_fds_size() const { return _impl_.fds_.size(); }
inline int Fds::fds_size() const { return _internal_fds_size(); }
inline void Fds::clear_fds() { _impl_.fds_.Clear(); }
inline uint64_t Fds::_internal_fds(int index) const {
  return _impl_.fds_.Get(index);
}
inline uint64_t Fds::fds(int index) const {
  // @@protoc_insertion_point(field_get:generated.traces.Fds.fds)
  return _internal_fds(index);
}
inline void Fds::set_fds(int index, uint64_t value) {
  _impl_.fds_.Set(index, value);
  // @@protoc_insertion_point(field_set:generated.traces.Fds.fds)
}
inline void Fds::_internal_add_fds(uint64_t value) { _impl_.fds_.Add(value); }
inline void Fds::add_fds(uint64_t value) {
  _internal_add_fds(value);
  // @@protoc_insertion_point(field_add:generated.traces.Fds.fds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>&
Fds::_internal_fds() const {
  return _impl_.fds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& Fds::fds()
    const {
  // @@protoc_insertion_point(field_list:generated.traces.Fds.fds)
  return _internal_fds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>*
Fds::_internal_mutable_fds() {
  return &_impl_.fds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* Fds::mutable_fds() {
  // @@protoc_insertion_point(field_mutable_list:generated.traces.Fds.fds)
  return _internal_mutable_fds();
}

// -------------------------------------------------------------------

// Syscall

// int64 return_with_code = 1;
inline bool Syscall::_internal_has_return_with_code() const {
  return value_case() == kReturnWithCode;
}
inline bool Syscall::has_return_with_code() const {
  return _internal_has_return_with_code();
}
inline void Syscall::set_has_return_with_code() {
  _impl_._oneof_case_[0] = kReturnWithCode;
}
inline void Syscall::clear_return_with_code() {
  if (_internal_has_return_with_code()) {
    _impl_.value_.return_with_code_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Syscall::_internal_return_with_code() const {
  if (_internal_has_return_with_code()) {
    return _impl_.value_.return_with_code_;
  }
  return int64_t{0};
}
inline void Syscall::_internal_set_return_with_code(int64_t value) {
  if (!_internal_has_return_with_code()) {
    clear_value();
    set_has_return_with_code();
  }
  _impl_.value_.return_with_code_ = value;
}
inline int64_t Syscall::return_with_code() const {
  // @@protoc_insertion_point(field_get:generated.traces.Syscall.return_with_code)
  return _internal_return_with_code();
}
inline void Syscall::set_return_with_code(int64_t value) {
  _internal_set_return_with_code(value);
  // @@protoc_insertion_point(field_set:generated.traces.Syscall.return_with_code)
}

// uint64 success_output_data = 2;
inline bool Syscall::_internal_has_success_output_data() const {
  return value_case() == kSuccessOutputData;
}
inline bool Syscall::has_success_output_data() const {
  return _internal_has_success_output_data();
}
inline void Syscall::set_has_success_output_data() {
  _impl_._oneof_case_[0] = kSuccessOutputData;
}
inline void Syscall::clear_success_output_data() {
  if (_internal_has_success_output_data()) {
    _impl_.value_.success_output_data_ = uint64_t{0u};
    clear_has_value();
  }
}
inline uint64_t Syscall::_internal_success_output_data() const {
  if (_internal_has_success_output_data()) {
    return _impl_.value_.success_output_data_;
  }
  return uint64_t{0u};
}
inline void Syscall::_internal_set_success_output_data(uint64_t value) {
  if (!_internal_has_success_output_data()) {
    clear_value();
    set_has_success_output_data();
  }
  _impl_.value_.success_output_data_ = value;
}
inline uint64_t Syscall::success_output_data() const {
  // @@protoc_insertion_point(field_get:generated.traces.Syscall.success_output_data)
  return _internal_success_output_data();
}
inline void Syscall::set_success_output_data(uint64_t value) {
  _internal_set_success_output_data(value);
  // @@protoc_insertion_point(field_set:generated.traces.Syscall.success_output_data)
}

// .generated.traces.IoData io_data = 3;
inline bool Syscall::_internal_has_io_data() const {
  return value_case() == kIoData;
}
inline bool Syscall::has_io_data() const { return _internal_has_io_data(); }
inline void Syscall::set_has_io_data() { _impl_._oneof_case_[0] = kIoData; }
inline void Syscall::clear_io_data() {
  if (_internal_has_io_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.io_data_;
    }
    clear_has_value();
  }
}
inline ::generated::traces::IoData* Syscall::release_io_data() {
  // @@protoc_insertion_point(field_release:generated.traces.Syscall.io_data)
  if (_internal_has_io_data()) {
    clear_has_value();
    ::generated::traces::IoData* temp = _impl_.value_.io_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.io_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::generated::traces::IoData& Syscall::_internal_io_data() const {
  return _internal_has_io_data()
             ? *_impl_.value_.io_data_
             : reinterpret_cast<::generated::traces::IoData&>(
                   ::generated::traces::_IoData_default_instance_);
}
inline const ::generated::traces::IoData& Syscall::io_data() const {
  // @@protoc_insertion_point(field_get:generated.traces.Syscall.io_data)
  return _internal_io_data();
}
inline ::generated::traces::IoData* Syscall::unsafe_arena_release_io_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:generated.traces.Syscall.io_data)
  if (_internal_has_io_data()) {
    clear_has_value();
    ::generated::traces::IoData* temp = _impl_.value_.io_data_;
    _impl_.value_.io_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Syscall::unsafe_arena_set_allocated_io_data(
    ::generated::traces::IoData* io_data) {
  clear_value();
  if (io_data) {
    set_has_io_data();
    _impl_.value_.io_data_ = io_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.traces.Syscall.io_data)
}
inline ::generated::traces::IoData* Syscall::_internal_mutable_io_data() {
  if (!_internal_has_io_data()) {
    clear_value();
    set_has_io_data();
    _impl_.value_.io_data_ = CreateMaybeMessage<::generated::traces::IoData>(
        GetArenaForAllocation());
  }
  return _impl_.value_.io_data_;
}
inline ::generated::traces::IoData* Syscall::mutable_io_data() {
  ::generated::traces::IoData* _msg = _internal_mutable_io_data();
  // @@protoc_insertion_point(field_mutable:generated.traces.Syscall.io_data)
  return _msg;
}

// .generated.traces.Terminated terminated = 4;
inline bool Syscall::_internal_has_terminated() const {
  return value_case() == kTerminated;
}
inline bool Syscall::has_terminated() const {
  return _internal_has_terminated();
}
inline void Syscall::set_has_terminated() {
  _impl_._oneof_case_[0] = kTerminated;
}
inline void Syscall::clear_terminated() {
  if (_internal_has_terminated()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.terminated_;
    }
    clear_has_value();
  }
}
inline ::generated::traces::Terminated* Syscall::release_terminated() {
  // @@protoc_insertion_point(field_release:generated.traces.Syscall.terminated)
  if (_internal_has_terminated()) {
    clear_has_value();
    ::generated::traces::Terminated* temp = _impl_.value_.terminated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.terminated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::generated::traces::Terminated& Syscall::_internal_terminated()
    const {
  return _internal_has_terminated()
             ? *_impl_.value_.terminated_
             : reinterpret_cast<::generated::traces::Terminated&>(
                   ::generated::traces::_Terminated_default_instance_);
}
inline const ::generated::traces::Terminated& Syscall::terminated() const {
  // @@protoc_insertion_point(field_get:generated.traces.Syscall.terminated)
  return _internal_terminated();
}
inline ::generated::traces::Terminated*
Syscall::unsafe_arena_release_terminated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:generated.traces.Syscall.terminated)
  if (_internal_has_terminated()) {
    clear_has_value();
    ::generated::traces::Terminated* temp = _impl_.value_.terminated_;
    _impl_.value_.terminated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Syscall::unsafe_arena_set_allocated_terminated(
    ::generated::traces::Terminated* terminated) {
  clear_value();
  if (terminated) {
    set_has_terminated();
    _impl_.value_.terminated_ = terminated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.traces.Syscall.terminated)
}
inline ::generated::traces::Terminated*
Syscall::_internal_mutable_terminated() {
  if (!_internal_has_terminated()) {
    clear_value();
    set_has_terminated();
    _impl_.value_.terminated_ =
        CreateMaybeMessage<::generated::traces::Terminated>(
            GetArenaForAllocation());
  }
  return _impl_.value_.terminated_;
}
inline ::generated::traces::Terminated* Syscall::mutable_terminated() {
  ::generated::traces::Terminated* _msg = _internal_mutable_terminated();
  // @@protoc_insertion_point(field_mutable:generated.traces.Syscall.terminated)
  return _msg;
}

// .generated.traces.Fds fds = 5;
inline bool Syscall::_internal_has_fds() const { return value_case() == kFds; }
inline bool Syscall::has_fds() const { return _internal_has_fds(); }
inline void Syscall::set_has_fds() { _impl_._oneof_case_[0] = kFds; }
inline void Syscall::clear_fds() {
  if (_internal_has_fds()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.fds_;
    }
    clear_has_value();
  }
}
inline ::generated::traces::Fds* Syscall::release_fds() {
  // @@protoc_insertion_point(field_release:generated.traces.Syscall.fds)
  if (_internal_has_fds()) {
    clear_has_value();
    ::generated::traces::Fds* temp = _impl_.value_.fds_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.fds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::generated::traces::Fds& Syscall::_internal_fds() const {
  return _internal_has_fds() ? *_impl_.value_.fds_
                             : reinterpret_cast<::generated::traces::Fds&>(
                                   ::generated::traces::_Fds_default_instance_);
}
inline const ::generated::traces::Fds& Syscall::fds() const {
  // @@protoc_insertion_point(field_get:generated.traces.Syscall.fds)
  return _internal_fds();
}
inline ::generated::traces::Fds* Syscall::unsafe_arena_release_fds() {
  // @@protoc_insertion_point(field_unsafe_arena_release:generated.traces.Syscall.fds)
  if (_internal_has_fds()) {
    clear_has_value();
    ::generated::traces::Fds* temp = _impl_.value_.fds_;
    _impl_.value_.fds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Syscall::unsafe_arena_set_allocated_fds(
    ::generated::traces::Fds* fds) {
  clear_value();
  if (fds) {
    set_has_fds();
    _impl_.value_.fds_ = fds;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.traces.Syscall.fds)
}
inline ::generated::traces::Fds* Syscall::_internal_mutable_fds() {
  if (!_internal_has_fds()) {
    clear_value();
    set_has_fds();
    _impl_.value_.fds_ =
        CreateMaybeMessage<::generated::traces::Fds>(GetArenaForAllocation());
  }
  return _impl_.value_.fds_;
}
inline ::generated::traces::Fds* Syscall::mutable_fds() {
  ::generated::traces::Fds* _msg = _internal_mutable_fds();
  // @@protoc_insertion_point(field_mutable:generated.traces.Syscall.fds)
  return _msg;
}

inline bool Syscall::has_value() const { return value_case() != VALUE_NOT_SET; }
inline void Syscall::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Syscall::ValueCase Syscall::value_case() const {
  return Syscall::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Syscalls

// repeated .generated.traces.Syscall syscalls = 1;
inline int Syscalls::_internal_syscalls_size() const {
  return _impl_.syscalls_.size();
}
inline int Syscalls::syscalls_size() const { return _internal_syscalls_size(); }
inline void Syscalls::clear_syscalls() { _impl_.syscalls_.Clear(); }
inline ::generated::traces::Syscall* Syscalls::mutable_syscalls(int index) {
  // @@protoc_insertion_point(field_mutable:generated.traces.Syscalls.syscalls)
  return _impl_.syscalls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::generated::traces::Syscall>*
Syscalls::mutable_syscalls() {
  // @@protoc_insertion_point(field_mutable_list:generated.traces.Syscalls.syscalls)
  return &_impl_.syscalls_;
}
inline const ::generated::traces::Syscall& Syscalls::_internal_syscalls(
    int index) const {
  return _impl_.syscalls_.Get(index);
}
inline const ::generated::traces::Syscall& Syscalls::syscalls(int index) const {
  // @@protoc_insertion_point(field_get:generated.traces.Syscalls.syscalls)
  return _internal_syscalls(index);
}
inline ::generated::traces::Syscall* Syscalls::_internal_add_syscalls() {
  return _impl_.syscalls_.Add();
}
inline ::generated::traces::Syscall* Syscalls::add_syscalls() {
  ::generated::traces::Syscall* _add = _internal_add_syscalls();
  // @@protoc_insertion_point(field_add:generated.traces.Syscalls.syscalls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<
    ::generated::traces::Syscall>&
Syscalls::syscalls() const {
  // @@protoc_insertion_point(field_list:generated.traces.Syscalls.syscalls)
  return _impl_.syscalls_;
}

// repeated bytes args = 2;
inline int Syscalls::_internal_args_size() const { return _impl_.args_.size(); }
inline int Syscalls::args_size() const { return _internal_args_size(); }
inline void Syscalls::clear_args() { _impl_.args_.Clear(); }
inline std::string* Syscalls::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:generated.traces.Syscalls.args)
  return _s;
}
inline const std::string& Syscalls::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const std::string& Syscalls::args(int index) const {
  // @@protoc_insertion_point(field_get:generated.traces.Syscalls.args)
  return _internal_args(index);
}
inline std::string* Syscalls::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:generated.traces.Syscalls.args)
  return _impl_.args_.Mutable(index);
}
inline void Syscalls::set_args(int index, const std::string& value) {
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:generated.traces.Syscalls.args)
}
inline void Syscalls::set_args(int index, std::string&& value) {
  _impl_.args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:generated.traces.Syscalls.args)
}
inline void Syscalls::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:generated.traces.Syscalls.args)
}
inline void Syscalls::set_args(int index, const void* value, size_t size) {
  _impl_.args_.Mutable(index)->assign(reinterpret_cast<const char*>(value),
                                      size);
  // @@protoc_insertion_point(field_set_pointer:generated.traces.Syscalls.args)
}
inline std::string* Syscalls::_internal_add_args() {
  return _impl_.args_.Add();
}
inline void Syscalls::add_args(const std::string& value) {
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:generated.traces.Syscalls.args)
}
inline void Syscalls::add_args(std::string&& value) {
  _impl_.args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:generated.traces.Syscalls.args)
}
inline void Syscalls::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:generated.traces.Syscalls.args)
}
inline void Syscalls::add_args(const void* value, size_t size) {
  _impl_.args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:generated.traces.Syscalls.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Syscalls::args() const {
  // @@protoc_insertion_point(field_list:generated.traces.Syscalls.args)
  return _impl_.args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Syscalls::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:generated.traces.Syscalls.args)
  return &_impl_.args_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Parts

// bytes tx_hash = 1;
inline void Parts::clear_tx_hash() { _impl_.tx_hash_.ClearToEmpty(); }
inline const std::string& Parts::tx_hash() const {
  // @@protoc_insertion_point(field_get:generated.traces.Parts.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Parts::set_tx_hash(ArgT0&& arg0,
                                                      ArgT... args) {
  _impl_.tx_hash_.SetBytes(static_cast<ArgT0&&>(arg0), args...,
                           GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:generated.traces.Parts.tx_hash)
}
inline std::string* Parts::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:generated.traces.Parts.tx_hash)
  return _s;
}
inline const std::string& Parts::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void Parts::_internal_set_tx_hash(const std::string& value) {
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Parts::_internal_mutable_tx_hash() {
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Parts::release_tx_hash() {
  // @@protoc_insertion_point(field_release:generated.traces.Parts.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void Parts::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
  } else {
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:generated.traces.Parts.tx_hash)
}

// repeated bytes input_cells = 2;
inline int Parts::_internal_input_cells_size() const {
  return _impl_.input_cells_.size();
}
inline int Parts::input_cells_size() const {
  return _internal_input_cells_size();
}
inline void Parts::clear_input_cells() { _impl_.input_cells_.Clear(); }
inline std::string* Parts::add_input_cells() {
  std::string* _s = _internal_add_input_cells();
  // @@protoc_insertion_point(field_add_mutable:generated.traces.Parts.input_cells)
  return _s;
}
inline const std::string& Parts::_internal_input_cells(int index) const {
  return _impl_.input_cells_.Get(index);
}
inline const std::string& Parts::input_cells(int index) const {
  // @@protoc_insertion_point(field_get:generated.traces.Parts.input_cells)
  return _internal_input_cells(index);
}
inline std::string* Parts::mutable_input_cells(int index) {
  // @@protoc_insertion_point(field_mutable:generated.traces.Parts.input_cells)
  return _impl_.input_cells_.Mutable(index);
}
inline void Parts::set_input_cells(int index, const std::string& value) {
  _impl_.input_cells_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:generated.traces.Parts.input_cells)
}
inline void Parts::set_input_cells(int index, std::string&& value) {
  _impl_.input_cells_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:generated.traces.Parts.input_cells)
}
inline void Parts::set_input_cells(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_cells_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:generated.traces.Parts.input_cells)
}
inline void Parts::set_input_cells(int index, const void* value, size_t size) {
  _impl_.input_cells_.Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:generated.traces.Parts.input_cells)
}
inline std::string* Parts::_internal_add_input_cells() {
  return _impl_.input_cells_.Add();
}
inline void Parts::add_input_cells(const std::string& value) {
  _impl_.input_cells_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:generated.traces.Parts.input_cells)
}
inline void Parts::add_input_cells(std::string&& value) {
  _impl_.input_cells_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:generated.traces.Parts.input_cells)
}
inline void Parts::add_input_cells(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_cells_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:generated.traces.Parts.input_cells)
}
inline void Parts::add_input_cells(const void* value, size_t size) {
  _impl_.input_cells_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:generated.traces.Parts.input_cells)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Parts::input_cells() const {
  // @@protoc_insertion_point(field_list:generated.traces.Parts.input_cells)
  return _impl_.input_cells_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Parts::mutable_input_cells() {
  // @@protoc_insertion_point(field_mutable_list:generated.traces.Parts.input_cells)
  return &_impl_.input_cells_;
}

// repeated bytes input_cell_data = 3;
inline int Parts::_internal_input_cell_data_size() const {
  return _impl_.input_cell_data_.size();
}
inline int Parts::input_cell_data_size() const {
  return _internal_input_cell_data_size();
}
inline void Parts::clear_input_cell_data() { _impl_.input_cell_data_.Clear(); }
inline std::string* Parts::add_input_cell_data() {
  std::string* _s = _internal_add_input_cell_data();
  // @@protoc_insertion_point(field_add_mutable:generated.traces.Parts.input_cell_data)
  return _s;
}
inline const std::string& Parts::_internal_input_cell_data(int index) const {
  return _impl_.input_cell_data_.Get(index);
}
inline const std::string& Parts::input_cell_data(int index) const {
  // @@protoc_insertion_point(field_get:generated.traces.Parts.input_cell_data)
  return _internal_input_cell_data(index);
}
inline std::string* Parts::mutable_input_cell_data(int index) {
  // @@protoc_insertion_point(field_mutable:generated.traces.Parts.input_cell_data)
  return _impl_.input_cell_data_.Mutable(index);
}
inline void Parts::set_input_cell_data(int index, const std::string& value) {
  _impl_.input_cell_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:generated.traces.Parts.input_cell_data)
}
inline void Parts::set_input_cell_data(int index, std::string&& value) {
  _impl_.input_cell_data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:generated.traces.Parts.input_cell_data)
}
inline void Parts::set_input_cell_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_cell_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:generated.traces.Parts.input_cell_data)
}
inline void Parts::set_input_cell_data(int index, const void* value,
                                       size_t size) {
  _impl_.input_cell_data_.Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:generated.traces.Parts.input_cell_data)
}
inline std::string* Parts::_internal_add_input_cell_data() {
  return _impl_.input_cell_data_.Add();
}
inline void Parts::add_input_cell_data(const std::string& value) {
  _impl_.input_cell_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:generated.traces.Parts.input_cell_data)
}
inline void Parts::add_input_cell_data(std::string&& value) {
  _impl_.input_cell_data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:generated.traces.Parts.input_cell_data)
}
inline void Parts::add_input_cell_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_cell_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:generated.traces.Parts.input_cell_data)
}
inline void Parts::add_input_cell_data(const void* value, size_t size) {
  _impl_.input_cell_data_.Add()->assign(reinterpret_cast<const char*>(value),
                                        size);
  // @@protoc_insertion_point(field_add_pointer:generated.traces.Parts.input_cell_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Parts::input_cell_data() const {
  // @@protoc_insertion_point(field_list:generated.traces.Parts.input_cell_data)
  return _impl_.input_cell_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Parts::mutable_input_cell_data() {
  // @@protoc_insertion_point(field_mutable_list:generated.traces.Parts.input_cell_data)
  return &_impl_.input_cell_data_;
}

// repeated bytes witnesses = 4;
inline int Parts::_internal_witnesses_size() const {
  return _impl_.witnesses_.size();
}
inline int Parts::witnesses_size() const { return _internal_witnesses_size(); }
inline void Parts::clear_witnesses() { _impl_.witnesses_.Clear(); }
inline std::string* Parts::add_witnesses() {
  std::string* _s = _internal_add_witnesses();
  // @@protoc_insertion_point(field_add_mutable:generated.traces.Parts.witnesses)
  return _s;
}
inline const std::string& Parts::_internal_witnesses(int index) const {
  return _impl_.witnesses_.Get(index);
}
inline const std::string& Parts::witnesses(int index) const {
  // @@protoc_insertion_point(field_get:generated.traces.Parts.witnesses)
  return _internal_witnesses(index);
}
inline std::string* Parts::mutable_witnesses(int index) {
  // @@protoc_insertion_point(field_mutable:generated.traces.Parts.witnesses)
  return _impl_.witnesses_.Mutable(index);
}
inline void Parts::set_witnesses(int index, const std::string& value) {
  _impl_.witnesses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:generated.traces.Parts.witnesses)
}
inline void Parts::set_witnesses(int index, std::string&& value) {
  _impl_.witnesses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:generated.traces.Parts.witnesses)
}
inline void Parts::set_witnesses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.witnesses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:generated.traces.Parts.witnesses)
}
inline void Parts::set_witnesses(int index, const void* value, size_t size) {
  _impl_.witnesses_.Mutable(index)->assign(reinterpret_cast<const char*>(value),
                                           size);
  // @@protoc_insertion_point(field_set_pointer:generated.traces.Parts.witnesses)
}
inline std::string* Parts::_internal_add_witnesses() {
  return _impl_.witnesses_.Add();
}
inline void Parts::add_witnesses(const std::string& value) {
  _impl_.witnesses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:generated.traces.Parts.witnesses)
}
inline void Parts::add_witnesses(std::string&& value) {
  _impl_.witnesses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:generated.traces.Parts.witnesses)
}
inline void Parts::add_witnesses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.witnesses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:generated.traces.Parts.witnesses)
}
inline void Parts::add_witnesses(const void* value, size_t size) {
  _impl_.witnesses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:generated.traces.Parts.witnesses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Parts::witnesses() const {
  // @@protoc_insertion_point(field_list:generated.traces.Parts.witnesses)
  return _impl_.witnesses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Parts::mutable_witnesses() {
  // @@protoc_insertion_point(field_mutable_list:generated.traces.Parts.witnesses)
  return &_impl_.witnesses_;
}

// repeated uint64 inherited_fds = 5;
inline int Parts::_internal_inherited_fds_size() const {
  return _impl_.inherited_fds_.size();
}
inline int Parts::inherited_fds_size() const {
  return _internal_inherited_fds_size();
}
inline void Parts::clear_inherited_fds() { _impl_.inherited_fds_.Clear(); }
inline uint64_t Parts::_internal_inherited_fds(int index) const {
  return _impl_.inherited_fds_.Get(index);
}
inline uint64_t Parts::inherited_fds(int index) const {
  // @@protoc_insertion_point(field_get:generated.traces.Parts.inherited_fds)
  return _internal_inherited_fds(index);
}
inline void Parts::set_inherited_fds(int index, uint64_t value) {
  _impl_.inherited_fds_.Set(index, value);
  // @@protoc_insertion_point(field_set:generated.traces.Parts.inherited_fds)
}
inline void Parts::_internal_add_inherited_fds(uint64_t value) {
  _impl_.inherited_fds_.Add(value);
}
inline void Parts::add_inherited_fds(uint64_t value) {
  _internal_add_inherited_fds(value);
  // @@protoc_insertion_point(field_add:generated.traces.Parts.inherited_fds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>&
Parts::_internal_inherited_fds() const {
  return _impl_.inherited_fds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>&
Parts::inherited_fds() const {
  // @@protoc_insertion_point(field_list:generated.traces.Parts.inherited_fds)
  return _internal_inherited_fds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>*
Parts::_internal_mutable_inherited_fds() {
  return &_impl_.inherited_fds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>*
Parts::mutable_inherited_fds() {
  // @@protoc_insertion_point(field_mutable_list:generated.traces.Parts.inherited_fds)
  return _internal_mutable_inherited_fds();
}

// map<uint64, bytes> read_data = 6;
inline int Parts::_internal_read_data_size() const {
  return _impl_.read_data_.size();
}
inline int Parts::read_data_size() const { return _internal_read_data_size(); }
inline void Parts::clear_read_data() { _impl_.read_data_.Clear(); }
inline const ::PROTOBUF_NAMESPACE_ID::Map<uint64_t, std::string>&
Parts::_internal_read_data() const {
  return _impl_.read_data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<uint64_t, std::string>&
Parts::read_data() const {
  // @@protoc_insertion_point(field_map:generated.traces.Parts.read_data)
  return _internal_read_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<uint64_t, std::string>*
Parts::_internal_mutable_read_data() {
  return _impl_.read_data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<uint64_t, std::string>*
Parts::mutable_read_data() {
  // @@protoc_insertion_point(field_mutable_map:generated.traces.Parts.read_data)
  return _internal_mutable_read_data();
}

// .generated.traces.Syscalls other_syscalls = 7;
inline bool Parts::_internal_has_other_syscalls() const {
  return this != internal_default_instance() &&
         _impl_.other_syscalls_ != nullptr;
}
inline bool Parts::has_other_syscalls() const {
  return _internal_has_other_syscalls();
}
inline void Parts::clear_other_syscalls() {
  if (GetArenaForAllocation() == nullptr && _impl_.other_syscalls_ != nullptr) {
    delete _impl_.other_syscalls_;
  }
  _impl_.other_syscalls_ = nullptr;
}
inline const ::generated::traces::Syscalls& Parts::_internal_other_syscalls()
    const {
  const ::generated::traces::Syscalls* p = _impl_.other_syscalls_;
  return p != nullptr ? *p
                      : reinterpret_cast<const ::generated::traces::Syscalls&>(
                            ::generated::traces::_Syscalls_default_instance_);
}
inline const ::generated::traces::Syscalls& Parts::other_syscalls() const {
  // @@protoc_insertion_point(field_get:generated.traces.Parts.other_syscalls)
  return _internal_other_syscalls();
}
inline void Parts::unsafe_arena_set_allocated_other_syscalls(
    ::generated::traces::Syscalls* other_syscalls) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(
        _impl_.other_syscalls_);
  }
  _impl_.other_syscalls_ = other_syscalls;
  if (other_syscalls) {
  } else {
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.traces.Parts.other_syscalls)
}
inline ::generated::traces::Syscalls* Parts::release_other_syscalls() {
  ::generated::traces::Syscalls* temp = _impl_.other_syscalls_;
  _impl_.other_syscalls_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::generated::traces::Syscalls*
Parts::unsafe_arena_release_other_syscalls() {
  // @@protoc_insertion_point(field_release:generated.traces.Parts.other_syscalls)

  ::generated::traces::Syscalls* temp = _impl_.other_syscalls_;
  _impl_.other_syscalls_ = nullptr;
  return temp;
}
inline ::generated::traces::Syscalls*
Parts::_internal_mutable_other_syscalls() {
  if (_impl_.other_syscalls_ == nullptr) {
    auto* p = CreateMaybeMessage<::generated::traces::Syscalls>(
        GetArenaForAllocation());
    _impl_.other_syscalls_ = p;
  }
  return _impl_.other_syscalls_;
}
inline ::generated::traces::Syscalls* Parts::mutable_other_syscalls() {
  ::generated::traces::Syscalls* _msg = _internal_mutable_other_syscalls();
  // @@protoc_insertion_point(field_mutable:generated.traces.Parts.other_syscalls)
  return _msg;
}
inline void Parts::set_allocated_other_syscalls(
    ::generated::traces::Syscalls* other_syscalls) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.other_syscalls_;
  }
  if (other_syscalls) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(other_syscalls);
    if (message_arena != submessage_arena) {
      other_syscalls = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, other_syscalls, submessage_arena);
    }

  } else {
  }
  _impl_.other_syscalls_ = other_syscalls;
  // @@protoc_insertion_point(field_set_allocated:generated.traces.Parts.other_syscalls)
}

// -------------------------------------------------------------------

// Root

// .generated.traces.Parts parts = 1;
inline bool Root::_internal_has_parts() const { return value_case() == kParts; }
inline bool Root::has_parts() const { return _internal_has_parts(); }
inline void Root::set_has_parts() { _impl_._oneof_case_[0] = kParts; }
inline void Root::clear_parts() {
  if (_internal_has_parts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.parts_;
    }
    clear_has_value();
  }
}
inline ::generated::traces::Parts* Root::release_parts() {
  // @@protoc_insertion_point(field_release:generated.traces.Root.parts)
  if (_internal_has_parts()) {
    clear_has_value();
    ::generated::traces::Parts* temp = _impl_.value_.parts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.parts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::generated::traces::Parts& Root::_internal_parts() const {
  return _internal_has_parts()
             ? *_impl_.value_.parts_
             : reinterpret_cast<::generated::traces::Parts&>(
                   ::generated::traces::_Parts_default_instance_);
}
inline const ::generated::traces::Parts& Root::parts() const {
  // @@protoc_insertion_point(field_get:generated.traces.Root.parts)
  return _internal_parts();
}
inline ::generated::traces::Parts* Root::unsafe_arena_release_parts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:generated.traces.Root.parts)
  if (_internal_has_parts()) {
    clear_has_value();
    ::generated::traces::Parts* temp = _impl_.value_.parts_;
    _impl_.value_.parts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_parts(
    ::generated::traces::Parts* parts) {
  clear_value();
  if (parts) {
    set_has_parts();
    _impl_.value_.parts_ = parts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.traces.Root.parts)
}
inline ::generated::traces::Parts* Root::_internal_mutable_parts() {
  if (!_internal_has_parts()) {
    clear_value();
    set_has_parts();
    _impl_.value_.parts_ =
        CreateMaybeMessage<::generated::traces::Parts>(GetArenaForAllocation());
  }
  return _impl_.value_.parts_;
}
inline ::generated::traces::Parts* Root::mutable_parts() {
  ::generated::traces::Parts* _msg = _internal_mutable_parts();
  // @@protoc_insertion_point(field_mutable:generated.traces.Root.parts)
  return _msg;
}

// .generated.traces.Syscalls syscalls = 3;
inline bool Root::_internal_has_syscalls() const {
  return value_case() == kSyscalls;
}
inline bool Root::has_syscalls() const { return _internal_has_syscalls(); }
inline void Root::set_has_syscalls() { _impl_._oneof_case_[0] = kSyscalls; }
inline void Root::clear_syscalls() {
  if (_internal_has_syscalls()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.syscalls_;
    }
    clear_has_value();
  }
}
inline ::generated::traces::Syscalls* Root::release_syscalls() {
  // @@protoc_insertion_point(field_release:generated.traces.Root.syscalls)
  if (_internal_has_syscalls()) {
    clear_has_value();
    ::generated::traces::Syscalls* temp = _impl_.value_.syscalls_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.syscalls_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::generated::traces::Syscalls& Root::_internal_syscalls() const {
  return _internal_has_syscalls()
             ? *_impl_.value_.syscalls_
             : reinterpret_cast<::generated::traces::Syscalls&>(
                   ::generated::traces::_Syscalls_default_instance_);
}
inline const ::generated::traces::Syscalls& Root::syscalls() const {
  // @@protoc_insertion_point(field_get:generated.traces.Root.syscalls)
  return _internal_syscalls();
}
inline ::generated::traces::Syscalls* Root::unsafe_arena_release_syscalls() {
  // @@protoc_insertion_point(field_unsafe_arena_release:generated.traces.Root.syscalls)
  if (_internal_has_syscalls()) {
    clear_has_value();
    ::generated::traces::Syscalls* temp = _impl_.value_.syscalls_;
    _impl_.value_.syscalls_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_syscalls(
    ::generated::traces::Syscalls* syscalls) {
  clear_value();
  if (syscalls) {
    set_has_syscalls();
    _impl_.value_.syscalls_ = syscalls;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:generated.traces.Root.syscalls)
}
inline ::generated::traces::Syscalls* Root::_internal_mutable_syscalls() {
  if (!_internal_has_syscalls()) {
    clear_value();
    set_has_syscalls();
    _impl_.value_.syscalls_ = CreateMaybeMessage<::generated::traces::Syscalls>(
        GetArenaForAllocation());
  }
  return _impl_.value_.syscalls_;
}
inline ::generated::traces::Syscalls* Root::mutable_syscalls() {
  ::generated::traces::Syscalls* _msg = _internal_mutable_syscalls();
  // @@protoc_insertion_point(field_mutable:generated.traces.Root.syscalls)
  return _msg;
}

inline bool Root::has_value() const { return value_case() != VALUE_NOT_SET; }
inline void Root::clear_has_value() { _impl_._oneof_case_[0] = VALUE_NOT_SET; }
inline Root::ValueCase Root::value_case() const {
  return Root::ValueCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

}  // namespace traces
}  // namespace generated

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_traces_2eproto
